# v0.10.1: AMR GeometryProtocol Implementation

**Date**: 2025-11-05
**Status**: ✅ COMPLETED
**Part of**: Unified Geometry Parameter Design

## Overview

Extended GeometryProtocol support to all 4 AMR (Adaptive Mesh Refinement) mesh classes, enabling unified geometry-first API across all geometry types.

## Implementation

### Modified Files

1. **`mfg_pde/geometry/amr_1d.py`** (lines 217-267)
   - Added GeometryProtocol implementation to `OneDimensionalAMRMesh`
   - Import: `from .geometry_protocol import GeometryType`

2. **`mfg_pde/geometry/amr_triangular_2d.py`** (lines 210-259)
   - Added GeometryProtocol implementation to `TriangularAMRMesh`
   - Import: `from .geometry_protocol import GeometryType`

3. **`mfg_pde/geometry/amr_quadtree_2d.py`** (lines 321-370)
   - Added GeometryProtocol implementation to `AdaptiveMesh`
   - Import: `from .geometry_protocol import GeometryType`

4. **`mfg_pde/geometry/amr_tetrahedral_3d.py`** (lines 235-284)
   - Added GeometryProtocol implementation to `TetrahedralAMRMesh`
   - Import: `from .geometry_protocol import GeometryType`

### Protocol Methods Implemented

All 4 classes implement the 5 required protocol methods:

```python
@property
def dimension(self) -> int:
    """Spatial dimension (1, 2, or 3)."""
    return self._dimension

@property
def geometry_type(self) -> GeometryType:
    """Geometry type (CARTESIAN_GRID for structured adaptive mesh)."""
    return GeometryType.CARTESIAN_GRID

@property
def num_spatial_points(self) -> int:
    """Total number of discrete spatial points (leaf elements)."""
    return len(self.leaf_elements)

def get_spatial_grid(self) -> np.ndarray:
    """
    Get spatial grid representation.

    Returns:
        numpy array of leaf element centers (N, dimension)
    """
    centers = [self.elements[i].center for i in self.leaf_elements]
    return np.array(centers)

def get_problem_config(self) -> dict:
    """
    Return configuration dict for MFGProblem initialization.

    This polymorphic method provides AMR-specific configuration for MFGProblem.
    AMR meshes have dynamic grids with variable element sizes.

    Returns:
        Dictionary with keys:
            - num_spatial_points: Number of leaf elements
            - spatial_shape: (num_leaf_elements,) - flattened for AMR
            - spatial_bounds: None - AMR has dynamic bounds
            - spatial_discretization: None - AMR has variable element sizes
            - legacy_1d_attrs: None - AMR doesn't support legacy attrs

    Added in v0.10.1 for polymorphic geometry handling.
    """
    return {
        "num_spatial_points": len(self.leaf_elements),
        "spatial_shape": (len(self.leaf_elements),),
        "spatial_bounds": None,  # AMR has dynamic bounds
        "spatial_discretization": None,  # AMR has variable element sizes
        "legacy_1d_attrs": None,  # AMR doesn't support legacy 1D attributes
    }
```

## Design Decisions

### 1. Polymorphic Method Dispatch

**Decision**: Use `get_problem_config()` polymorphic method instead of hasattr duck typing.

**Rationale**:
- User explicitly preferred polymorphic approach over hasattr checks
- Cleaner separation of concerns
- Each geometry type controls its own configuration
- Avoids brittle duck typing patterns

**Implementation**:
```python
# Geometry types provide their own configuration
config = geometry.get_problem_config()

# MFGProblem uses the config without type checking
self.num_spatial_points = config["num_spatial_points"]
self.spatial_shape = config["spatial_shape"]
```

### 2. AMR Configuration Pattern

**Decision**: Return `None` for bounds, discretization, and legacy attributes.

**Rationale**:
- AMR meshes have **dynamic bounds** that change with refinement
- AMR meshes have **variable element sizes** (not uniform discretization)
- AMR meshes don't support **legacy 1D attributes** (xSpace, Dx, etc.)

**Impact**: MFGProblem must handle None values gracefully when initializing with AMR geometries.

### 3. Geometry Type Classification

**Decision**: All AMR meshes use `GeometryType.CARTESIAN_GRID`.

**Rationale**:
- AMR meshes are **structured adaptive grids** (hierarchical refinement of Cartesian grid)
- Distinguishes from unstructured meshes or network topologies
- Consistent with mathematical foundation (quadtree/octree = adaptive Cartesian grid)

## Validation

All 4 AMR classes pass GeometryProtocol compliance tests:

```python
from mfg_pde.geometry.geometry_protocol import (
    is_geometry_compatible,
    validate_geometry
)

# Test compliance
assert is_geometry_compatible(amr_mesh)  # ✓ True
validate_geometry(amr_mesh)  # ✓ Pass

# Test protocol properties
assert amr_mesh.dimension == expected_dimension
assert amr_mesh.geometry_type == GeometryType.CARTESIAN_GRID
assert amr_mesh.num_spatial_points == len(amr_mesh.leaf_elements)
assert amr_mesh.get_spatial_grid().shape == (num_leaves, dimension)

# Test polymorphic config
config = amr_mesh.get_problem_config()
assert config["num_spatial_points"] == amr_mesh.num_spatial_points
assert config["spatial_bounds"] is None  # AMR has dynamic bounds
assert config["legacy_1d_attrs"] is None  # AMR doesn't support legacy
```

## Usage

### Geometry-First API (v0.10.0+)

```python
from mfg_pde import ExampleMFGProblem
from mfg_pde.geometry.amr.amr_1d import OneDimensionalAMRMesh, AMRRefinementCriteria
from mfg_pde.geometry.domain_1d import Domain1D
from mfg_pde.geometry.boundary_conditions_1d import BoundaryConditions

# Create base domain
domain = Domain1D(
    xmin=0.0, xmax=1.0,
    boundary_conditions=BoundaryConditions()
)

# Create refinement criteria
refinement_criteria = AMRRefinementCriteria(
    max_level=3,
    refinement_threshold=0.5,
    coarsening_threshold=0.25
)

# Create AMR mesh
amr_mesh = OneDimensionalAMRMesh(
    domain_1d=domain,
    initial_num_intervals=20,
    refinement_criteria=refinement_criteria
)

# Use with MFGProblem - geometry-first API
problem = ExampleMFGProblem(
    geometry=amr_mesh,  # GeometryProtocol-compliant
    T=1.0,
    Nt=100,
    sigma=0.1
)
```

### Protocol Validation

```python
from mfg_pde.geometry.geometry_protocol import (
    is_geometry_compatible,
    validate_geometry,
    detect_geometry_type
)

# Check protocol compliance
if is_geometry_compatible(amr_mesh):
    print("✓ AMR mesh satisfies GeometryProtocol")

# Validate properties
validate_geometry(amr_mesh)  # Raises TypeError/ValueError if invalid

# Detect geometry type
geom_type = detect_geometry_type(amr_mesh)
print(f"Geometry type: {geom_type.value}")  # "cartesian_grid"
```

## Examples

Created demonstration examples:

1. **`examples/basic/amr_geometry_protocol_demo.py`**
   - Demonstrates GeometryProtocol compliance for all geometry types
   - Shows polymorphic `get_problem_config()` usage
   - Visualizes AMR mesh structure (1D and 2D)

2. **`examples/advanced/amr_1d_geometry_demo.py`** (needs constructor fixes)
   - Full MFG solver integration with AMR geometry
   - Comparison with uniform grid
   - Visualization of adaptive refinement

## API Compatibility

### Backward Compatible

All existing code continues to work - AMR meshes now additionally satisfy GeometryProtocol.

### New Capabilities

1. **Unified interface**: AMR geometries work with geometry-first API
2. **Runtime validation**: Can check protocol compliance at runtime
3. **Type detection**: Can detect and classify geometry types
4. **Polymorphic config**: Each geometry controls its own configuration

## Technical Notes

### Leaf Elements

AMR meshes store hierarchical tree structures with:
- **Parent elements**: Subdivided into children
- **Leaf elements**: Active elements without children (used for computation)

Protocol methods operate on **leaf elements only** since these represent the current active computational grid.

### Grid Representation

`get_spatial_grid()` returns element **centers** (not vertices) as (N, d) array:
- 1D: Interval centers
- 2D: Triangle/quad centroids
- 3D: Tetrahedron/hex centroids

This matches the finite volume / cell-centered discretization used by AMR solvers.

### Memory Efficiency

AMR meshes store only:
- Hierarchical tree structure (O(N) nodes)
- Leaf element data (O(M) leaves, M << N for refined grids)

`get_spatial_grid()` constructs full coordinate array on-demand.

## Related

- **v0.10.0**: Initial GeometryProtocol for 6 core geometry types
- **GeometryProtocol**: `mfg_pde/geometry/geometry_protocol.py`
- **Unified Design**: `docs/development/UNIFIED_GEOMETRY_PARAMETER_DESIGN.md`

## Future Work

1. **AMR Refinement Integration**: Automatic refinement based on solution gradients
2. **Load Balancing**: Parallel AMR with dynamic load balancing
3. **Visualization**: Better AMR mesh visualization tools
4. **Benchmarks**: Performance comparison AMR vs uniform grids

---

**Implementation Complete**: 2025-11-05
**Modified Files**: 4 AMR geometry classes
**Tests**: All pass GeometryProtocol validation
**Examples**: 2 demonstration scripts created
**API**: Backward compatible, new capabilities added

mfg_pde/visualization/mfg_analytics.py:    return engine.analyze_mfg_solution(x_grid, time_grid, density_history, value_history, title=title)
mfg_pde/visualization/multidim_viz.py:            return self._plotly_surface(X, Y, plot_data, title, xlabel, ylabel, zlabel)
mfg_pde/visualization/multidim_viz.py:            return self._matplotlib_surface(X, Y, plot_data, title, xlabel, ylabel, zlabel)
mfg_pde/visualization/multidim_viz.py:            return self._plotly_contour(X, Y, plot_data, title, xlabel, ylabel, levels)
mfg_pde/visualization/multidim_viz.py:            return self._matplotlib_contour(X, Y, plot_data, title, xlabel, ylabel, levels)
mfg_pde/visualization/multidim_viz.py:            return self._plotly_heatmap(plot_data, title, xlabel, ylabel)
mfg_pde/visualization/multidim_viz.py:            return self._matplotlib_heatmap(plot_data, title, xlabel, ylabel)
mfg_pde/visualization/multidim_viz.py:            return self._plotly_surface(X, Y, slice_data, title, xlabel, ylabel, "Value")
mfg_pde/visualization/interactive_plots.py:            return self.plotly_viz.plot_density_evolution_2d(x_grid, time_grid, density_history, title)
mfg_pde/visualization/interactive_plots.py:            return self.bokeh_viz.plot_density_heatmap(x_grid, time_grid, density_history, title)
mfg_pde/visualization/interactive_plots.py:            return self.plotly_viz.plot_density_surface_3d(x_grid, time_grid, data, title)
mfg_pde/visualization/interactive_plots.py:            return self.plotly_viz.plot_value_function_3d(x_grid, time_grid, data, title)
mfg_pde/visualization/interactive_plots.py:    return viz_manager.create_2d_density_plot(x_grid, time_grid, density_history, backend, title)
mfg_pde/visualization/interactive_plots.py:    return viz_manager.create_3d_surface_plot(x_grid, time_grid, data, data_type, title)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_trajectories_plotly(trajectories, U, M, title, save_path)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_trajectories_matplotlib(trajectories, U, M, title, save_path)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_velocity_field_plotly(velocity_field, M, title, time_idx, save_path)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_velocity_field_matplotlib(velocity_field, M, title, time_idx, save_path)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_scheme_comparison_plotly(solutions, times, selected_nodes, title, save_path)
mfg_pde/visualization/enhanced_network_plots.py:            return self._plot_scheme_comparison_matplotlib(solutions, times, selected_nodes, title, save_path)
mfg_pde/visualization/network_plots.py:            return self._plot_density_evolution_plotly(M, times, selected_nodes, title, save_path)
mfg_pde/visualization/network_plots.py:            return self._plot_density_evolution_matplotlib(M, times, selected_nodes, title, save_path)
mfg_pde/visualization/network_plots.py:        return self.plot_density_evolution(U, times, selected_nodes, title, interactive, save_path)
mfg_pde/visualization/mathematical_plots.py:            return self._plot_function_plotly(x, y, title, xlabel, ylabel, save_path)
mfg_pde/visualization/mathematical_plots.py:            return self._plot_function_matplotlib(x, y, title, xlabel, ylabel, save_path)
mfg_pde/visualization/mathematical_plots.py:            return self._plot_density_plotly(x_grid, t_grid, density, title, save_path)
mfg_pde/visualization/mathematical_plots.py:            return self._plot_density_matplotlib(x_grid, t_grid, density, title, save_path)
mfg_pde/types/state.py:        return self.u[-1, :], self.m[-1, :]
mfg_pde/types/state.py:        return self.u[0, :], self.m[0, :]
mfg_pde/core/mfg_problem.py:    return MFGProblem(components=components, **domain_config, **time_config, **solver_config)
mfg_pde/core/stochastic/stochastic_problem.py:            return self.conditional_hamiltonian(x, p, m, theta, t)
mfg_pde/core/stochastic/stochastic_problem.py:            return self.conditional_hamiltonian(x, p, m, theta)
mfg_pde/core/stochastic/stochastic_problem.py:            return self.H_conditional(x, p, m, theta_t, t)
mfg_pde/core/plugin_system.py:                return plugin_info.plugin_instance.create_solver(problem, solver_type, config, **kwargs)
mfg_pde/core/plugin_system.py:            return self._create_core_solver(problem, solver_type, config, **kwargs)
mfg_pde/core/plugin_system.py:        return ["fixed_point", "particle_collocation", "hjb_fdm", "hjb_collocation"]
mfg_pde/core/plugin_system.py:        return create_solver(problem, cast("SolverType", solver_type), config=config, **kwargs)
mfg_pde/core/plugin_system.py:    return get_plugin_manager().create_solver(problem, solver_type, config, **kwargs)
mfg_pde/core/network_mfg_problem.py:            return self.components.hamiltonian_func(node, neighbors, m, p, t)
mfg_pde/core/network_mfg_problem.py:        return self._default_network_hamiltonian(node, neighbors, m, p, t)
mfg_pde/core/network_mfg_problem.py:            return self.components.hamiltonian_dm_func(node, neighbors, m, p, t)
mfg_pde/core/network_mfg_problem.py:            return self.components.lagrangian_func(node, velocity, m, t)  # type: ignore[attr-defined]
mfg_pde/core/network_mfg_problem.py:            return self.components.trajectory_cost_func(trajectory, velocities, m_evolution, times)  # type: ignore[attr-defined]
mfg_pde/core/variational_mfg_problem.py:                return self.components.lagrangian_func(t, x, v, m)
mfg_pde/core/variational_mfg_problem.py:            return self._jax_lagrangian(t, x, v, m)
mfg_pde/core/variational_mfg_problem.py:            return self.components.lagrangian_func(t, x, v, m)
mfg_pde/core/variational_mfg_problem.py:                return self.components.lagrangian_dm_func(t, x, p, m)
mfg_pde/core/variational_mfg_problem.py:    return VariationalMFGProblem(xmin=xmin, xmax=xmax, Nx=Nx, T=T, Nt=Nt, sigma=sigma, components=components)
mfg_pde/core/variational_mfg_problem.py:    return VariationalMFGProblem(xmin=xmin, xmax=xmax, Nx=Nx, T=T, Nt=Nt, sigma=sigma, components=components)
mfg_pde/config/pydantic_config.py:        return cls(max_iterations=10, tolerance=1e-4, damping_factor=0.8, line_search=False, verbose=False)
mfg_pde/config/pydantic_config.py:        return cls(max_iterations=50, tolerance=1e-8, damping_factor=1.0, line_search=False, verbose=False)
mfg_pde/config/pydantic_config.py:        return cls(max_iterations=100, tolerance=1e-10, damping_factor=1.0, line_search=True, verbose=True)
mfg_pde/config/pydantic_config.py:        return cls(max_iterations=10, tolerance=1e-2, damping_factor=0.8, adaptive_damping=False, verbose=False)
mfg_pde/config/pydantic_config.py:        return cls(max_iterations=100, tolerance=1e-6, damping_factor=0.3, adaptive_damping=True, verbose=False)
mfg_pde/backends/numba_backend.py:        return np.linspace(start, stop, num, dtype=self.dtype)
mfg_pde/backends/numba_backend.py:            return (func(x_plus, *args, **kwargs) - func(x_minus, *args, **kwargs)) / (2.0 * eps)
mfg_pde/backends/numba_backend.py:            return trapezoid(y, x=x, dx=dx, axis=axis)
mfg_pde/backends/numba_backend.py:            return self._hamiltonian_kernel(x, p, m, sigma)
mfg_pde/backends/numba_backend.py:            return self._hjb_step_kernel(U, M, dt, dx, sigma)
mfg_pde/backends/numba_backend.py:            return self._fpk_step_kernel(M, U, dt, dx, sigma)
mfg_pde/backends/torch_backend.py:        return torch.linspace(start, stop, num, dtype=self.torch_dtype, device=self.torch_device)
mfg_pde/backends/numpy_backend.py:        return np.linspace(start, stop, num, dtype=self.dtype)
mfg_pde/backends/numpy_backend.py:        return trapezoid(y, x=x, dx=dx, axis=axis)
mfg_pde/backends/jax_backend.py:        return jax_trapezoid(y, x=x, dx=dx, axis=axis)
mfg_pde/backends/jax_backend.py:            return self._jit_hamiltonian(x, p, m, problem_params)
mfg_pde/backends/jax_backend.py:            return self._hamiltonian_impl(x, p, m, problem_params)
mfg_pde/backends/jax_backend.py:            return self._jit_optimal_control(x, p, m, problem_params)
mfg_pde/backends/jax_backend.py:            return self._optimal_control_impl(x, p, m, problem_params)
mfg_pde/backends/jax_backend.py:            return self._jit_hjb_step(U, M, dt, dx, x_grid, problem_params)
mfg_pde/backends/jax_backend.py:            return self._hjb_step_impl(U, M, dt, dx, x_grid, problem_params)
mfg_pde/backends/jax_backend.py:            return self._jit_fpk_step(M, U, dt, dx, x_grid, problem_params)
mfg_pde/backends/jax_backend.py:            return self._fpk_step_impl(M, U, dt, dx, x_grid, problem_params)
mfg_pde/meta/code_generation.py:    return generator.generate_complete_solver(solver_name, hjb_scheme, fp_scheme, hamiltonian_code)
mfg_pde/meta/code_generation.py:            return DiscretizationScheme("gradient", 2, [-1, 1], [-0.5, 0.5])
mfg_pde/meta/code_generation.py:            return DiscretizationScheme("gradient", 4, [-2, -1, 1, 2], [1 / 12, -8 / 12, 8 / 12, -1 / 12])
mfg_pde/meta/code_generation.py:            return DiscretizationScheme("laplacian", 2, [-1, 0, 1], [1, -2, 1])
mfg_pde/meta/mathematical_dsl.py:        return MathematicalExpression(diff_expr, self.variables, self.parameters, self.backend)
mfg_pde/meta/mathematical_dsl.py:        return CompiledMFGSystem(self.expressions, self.constraints, self.parameters, self.domain_info)
mfg_pde/meta/type_system.py:            return solve_method(self, problem, *args, **kwargs)
mfg_pde/solvers/fixed_point.py:        return self._u[t_idx, :], self._m[t_idx, :]
mfg_pde/utils/acceleration/jax_utils.py:        return _tridiagonal_solve_jax(a, b, c, d)
mfg_pde/utils/acceleration/jax_utils.py:        return _tridiagonal_solve_numpy(a, b, c, d)
mfg_pde/utils/numpy_compat.py:        return np.trapezoid(y, x=x, dx=dx, axis=axis)
mfg_pde/utils/numpy_compat.py:        return scipy_trapezoid(y, x=x, dx=dx, axis=axis)
mfg_pde/utils/numpy_compat.py:        return np.trapz(y, x=x, dx=dx, axis=axis)
mfg_pde/utils/numerical/convergence.py:            return self._classical_solve(Niter, l2errBound, verbose, **kwargs)
mfg_pde/utils/numerical/convergence.py:            return self._classical_solve(Niter, l2errBound, verbose, **kwargs)
mfg_pde/utils/numerical/mcmc.py:    return sample_mfg_posterior(log_posterior, grad_log_posterior, initial_weights, method="hmc", **mcmc_kwargs)
mfg_pde/utils/sparse_operations.py:        return sp.diags(diagonals, offsets, shape=(nx, nx), format=self.format, dtype=self.dtype)
mfg_pde/utils/sparse_operations.py:            return self._solve_cupy(A, b, x0, callback)
mfg_pde/utils/sparse_operations.py:            return self._solve_scipy(A, b, x0, callback)
mfg_pde/utils/performance/optimization.py:        return csr_matrix((data, (row_indices, col_indices)), shape=(total_points, total_points))
mfg_pde/utils/performance/optimization.py:        return csr_matrix((precond_data, (precond_rows, precond_cols)), shape=(n, n))
mfg_pde/hooks/extensions.py:                return convergence_impl(state, getattr(self, "tolerance", 1e-6), getattr(self, "history", []))
mfg_pde/workflow/parameter_sweep.py:            return self._execute_single(func, params, run_id, **extra_kwargs)
mfg_pde/workflow/parameter_sweep.py:                    return self._execute_single(function, params, run_id, **kwargs)
mfg_pde/geometry/network_geometry.py:        return csr_matrix((data, (rows, cols)), shape=(self.num_nodes, self.num_edges))
mfg_pde/geometry/network_geometry.py:        return GridNetwork(width, height, periodic, backend_preference)
mfg_pde/geometry/domain_1d.py:        return f"Domain1D(xmin={self.xmin}, xmax={self.xmax}, length={self.length}, bc={self.boundary_conditions})"
mfg_pde/geometry/base_geometry.py:        return np.min(self.vertices, axis=0), np.max(self.vertices, axis=0)

name: Code Quality and Formatting
#
# Cost-optimized workflow: Manual triggers only to reduce GitHub Actions usage
#
# To run manually:
# 1. Go to GitHub repo â†’ Actions tab â†’ "Code Quality and Formatting"
# 2. Click "Run workflow" â†’ Select branch â†’ Run
#
# Automatically runs on releases for quality assurance

on:
  workflow_dispatch:  # Manual trigger only to reduce costs
  release:
    types: [published]  # Run on releases for quality assurance

jobs:
  code-quality:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.12"]  # Updated to minimum supported version

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5  # Updated to latest
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[dev]  # Use pyproject.toml dev dependencies

    - name: Ruff Formatting Check
      run: |
        echo "ðŸŽ¨ Running Ruff formatter (10x faster than Black, uses pyproject.toml config)..."
        ruff format --check --diff mfg_pde/
        if [ $? -ne 0 ]; then
          echo "âŒ Formatting issues found. Run 'ruff format mfg_pde/' to fix."
          exit 1
        else
          echo "âœ… Code formatting is perfect."
        fi

    - name: Ruff Linting
      run: |
        echo "ðŸ” Running Ruff linter (replaces Pylint + flake8 + isort, uses pyproject.toml config)..."
        ruff check --output-format=github mfg_pde/
        if [ $? -ne 0 ]; then
          echo "âŒ Linting issues found. Run 'ruff check --fix mfg_pde/' to auto-fix."
          exit 1
        else
          echo "âœ… All linting checks passed."
        fi

    - name: Type checking with mypy
      run: |
        echo "ðŸ” Running mypy type checking (uses pyproject.toml config)..."
        mypy mfg_pde/
        if [ $? -ne 0 ]; then
          echo "âš ï¸ Type checking issues found (allowed during modernization)"
        else
          echo "âœ… Type checking passed."
        fi
        # Continue regardless of mypy result during modernization

    - name: Check parameter migration compliance
      run: |
        echo "ðŸ” Checking parameter migration system..."
        python -c "
        from mfg_pde.utils.parameter_migration import global_parameter_migrator
        print(f'âœ… Parameter migration system loaded with {len(global_parameter_migrator.mappings)} mappings')
        print('ðŸ“‹ Migration system ready for runtime parameter conversion')
        " || true
        # Note: Runtime migration is implemented, static analysis disabled during transition

  memory-safety:
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v5
      with:
        python-version: 3.12

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[performance]  # Use pyproject.toml performance dependencies

    - name: Memory usage test
      run: |
        echo "ðŸ§  Testing memory usage with small problem..."
        python -c "
        from mfg_pde import ExampleMFGProblem, create_fast_solver
        from mfg_pde.utils.memory_management import MemoryMonitor
        import psutil

        # Test with small problem to ensure memory monitoring works
        monitor = MemoryMonitor(max_memory_gb=2.0)

        problem = ExampleMFGProblem(Nx=20, Nt=10)
        solver = create_fast_solver(problem, 'fixed_point')

        initial_memory = monitor.get_current_memory_gb()
        print(f'Initial memory: {initial_memory:.3f} GB')

        result = solver.solve()

        final_memory = monitor.get_current_memory_gb()
        print(f'Final memory: {final_memory:.3f} GB')
        print(f'Memory increase: {(final_memory - initial_memory):.3f} GB')

        if final_memory > 1.0:  # Should not use more than 1GB for small problem
            print('âŒ Excessive memory usage detected')
            exit(1)
        else:
            print('âœ… Memory usage within acceptable limits')
        "

  performance-regression:
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v5
      with:
        python-version: 3.12

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[performance]

    - name: Performance regression test
      run: |
        echo "âš¡ Testing performance regression..."
        python -c "
        from mfg_pde import ExampleMFGProblem, create_fast_solver
        import time

        # Benchmark small problem
        problem = ExampleMFGProblem(Nx=30, Nt=20)
        solver = create_fast_solver(problem, 'fixed_point')

        start_time = time.time()
        result = solver.solve()
        execution_time = time.time() - start_time

        print(f'Execution time: {execution_time:.2f} seconds')

        # Should complete small problem in reasonable time
        if execution_time > 30:  # 30 second threshold
            print(f'âŒ Performance regression detected: {execution_time:.2f}s > 30s')
            exit(1)
        else:
            print(f'âœ… Performance within acceptable range: {execution_time:.2f}s')
        "

  documentation-quality:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v5
      with:
        python-version: 3.12

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[docs]

    - name: Check documentation completeness
      run: |
        echo "ðŸ“š Checking documentation completeness..."
        python -c "
        import ast
        import os
        from pathlib import Path

        def check_docstrings(file_path):
            with open(file_path, 'r') as f:
                tree = ast.parse(f.read())

            missing = []
            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                    if not node.name.startswith('_'):  # Public only
                        if not ast.get_docstring(node):
                            missing.append(f'{file_path}:{node.lineno}:{node.name}')
            return missing

        all_missing = []
        for py_file in Path('mfg_pde').rglob('*.py'):
            if '__pycache__' not in str(py_file):
                missing = check_docstrings(py_file)
                all_missing.extend(missing)

        if all_missing:
            print('âš ï¸  Missing docstrings (allowed during transition):')
            for missing in all_missing[:10]:  # Show first 10
                print(f'   {missing}')
            if len(all_missing) > 10:
                print(f'   ... and {len(all_missing) - 10} more')
        else:
            print('âœ… All public functions and classes have docstrings')
        "
